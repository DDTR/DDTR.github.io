{"pages":[{"title":"about","text":"蒋大志","link":"/about/index.html"},{"title":"All tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2022读书List","text":"开个blog记录一下今年读的书，想着做过的事都所有回响。 阅读范围不止专业领域，还有感兴趣的人文社科，经管，心理学，历史， 以及哲学。 专业领域 [已完成] 1. 《程序员的自我修养-链接，装载与库》 [已完成] 2. 《深度探索C++对象模型》 [TODO] 3. 《人月神话》 经管 [已完成] 1. 《财报就像一本故事书》 [TODO] 1. 《置身事内-中国政府与经济发展》 心理学 [TODO] 1. 《非暴力沟通》","link":"/2022/03/20/2022%E8%AF%BB%E4%B9%A6list/"},{"title":"Java 基础","text":"1 String final 类型， 不可变 不可变好处: (1) 可以做Hashmap 的key (2) 线程安全（StringBuffer 是线程安全的，StringBuilder 线程不安全） java 不能隐式向下转型，这样会精度丢失 2 继承 访问权限 修饰符 类内部 本包 子类 外部包 public * * * * protected * * * x default * * x x private * x x x 子类重写父类的方法访问权限不得低于父类 3 抽象类和抽象方法 抽象类不能被实例化 接口成员和方法默认是public，不能是privated 和 protected, 字段默认是static final 接口和抽象类使用选择 (1) 使用接口 不相关类实现同一方法 多重继承 (2) 使用抽象类 相关类共享代码 控制成员访问权限，不能全是public 需要继承非静态和非常量字段 4 equals() 实现 检查是否为同一个对象的引用，如果是返回true 检查是否是同一的类型，如果不是返回false 将Object 对象进行转型 判断每个关键域是否相等 5 初始化顺序 (1) 父类(静态变量， 静态语句块) (2) 子类(静态变量， 静态语句块) (3) 父类(实例变量， 普通语句块) (4) 父类(构造函数) (5) 子类(实例变量， 普通语句块) (6) 子类(构造函数) 6 异常","link":"/2019/08/01/Java%E5%9F%BA%E7%A1%80/"},{"title":"Java 复习笔记-JavaSE 基础篇","text":"1 包装类型的定义 1）八个基本类型对应有八个包装类，包装类是final 修饰的，无法被继承和重写的 2）包装类之间的比较: “==” 比较的是地址，在一定范围内是值比较, 以Integer为例， 比较源码如下： 12345public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127] return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象 return new Integer(i); // 如果不在，则创建一个新的Integer对象} Boolean, Character, Byte: &lt; 127 Short, Integer: &gt; -128 &amp;&amp; &lt; 127","link":"/2019/07/10/Java-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-JavaSE-%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"【随手记】UML类图","text":"UML类图 1 引言 UML类图是软件方案设计中常用的一种方式，之前一直对于类之间的关系认识存在模糊，借着整理项目架构之便将该知识点规整之下。 UML类图建模中类于类之间的关系有6种，按照关系从弱到强依次是依赖(Dependency)，关联(Association)，聚合(Aggregation)，组合(Composition)，实现(Realization)和泛化(Generlization)。 2 关系概述 关系名称 解释 代码表现 图形形状 依赖 最弱的关系，一种使用的关系，即A类实现需要B类的协助 局部变量，方法的参数或者对静态方法的调用 带箭头的虚线，指向被使用者，即A使用B，箭头指向B 关联 一种拥有的关系， 如老师和学生，丈夫和妻子，拥有关系可以是单向的，也可以是双向的 成员变量 带箭头的实心线（双向关联可以双箭头或者没有箭头），指向被拥有者，即A拥有B，箭头指向B 聚合 整体和部分的关系，部分可以脱离整体单独存在，如车和轮胎 成员变量 带空心菱形的实心线，菱形指向整体，即A是整体，B是部分，菱形指向A， 箭头指向B 组合 整体和部分的关系，部分不可以脱离整体单独存在，关系比聚合强一点，如公司和部门 成员变量 带实心菱形的实心线，菱形指向整体，即A拥有B，菱形指向A，箭头指向B 实现 实现类和接口的关系 类与接口 带三角箭头的虚线，箭头指向接口，即A是实现类，B是接口， 箭头指向B 泛化 继承，最强关系 继承 带三角箭头的实线，箭头指向父类，即A是父类，B是子类，箭头指向A 备注 ： 箭头指向被继承（实现/拥有/使用）或部分的那个类 3 图例","link":"/2022/02/08/UML%E7%B1%BB%E5%9B%BE/"},{"title":"hexo 常用命令手册","text":"hexo 博客命令 hexo new &quot;blog_name&quot;: 创建博文，博文路径为./source/_posts/blog_name.md hexo g: 文件生成（generator) hexo d: 文件部署(deploy) hexo s: 本地查看博客网址 详细hexo 命令见 hexo 指令详细文档","link":"/2020/01/15/hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"},{"title":"【读书笔记】《More Effective C++》- 操作符","text":"《More Effective C++》读书笔记 操作符 条款5 : 对定制的“类型转换函数”保持警觉 理解: 先说原因，类型转换函数在未预期的情况下被调用，导致结果可能不正确、不直观，很难调试。这种转换有两种，分别是隐式类型转换操作符和单自变量constructor: 隐式类型转换操作符： 示例如下：1operator double() const; 当类中定义该类型转换函数后，该类在使用中会被编译器调用而发生错误。 处理办法是用asDouble()这类函数代替operator double函数。 单自变量constructor: 单自变量构造函数是指构造函数只有一个参数或有很多参数但除第一个参数外其他参数都有默认值。 处理办法有两种（1）用explicit关键字声明单自变量构造函数，使得该函数不能发生隐式类型转换；（2）使用代理类来构建自变量构造函数。 条款6 : 区别increment/decrement操作符的前置(prefix)和后置(postfix)形式 理解: i++和++i的区别，给出实现代码即可看出区别 1234567891011121314// 前置式，先累加后取出，返回一个referenceUPInt&amp; UPInt::operator++(){ *this += 1; return *this;}// 后置式，取出后再累加，返回一个const对象const UPInt UPint::operator++(int){ UPInt oldValue = *this; ++(*this); // 这里调用前置++运算符 return oldValue;} 条款7 ： 千万不要重载&amp;&amp;，||和，操作符 理解: &amp;&amp;和||有骤死式语义，重载后会被函数调用语义替代，造成不可预期的效果。其中骤死式语义是指再一旦表达式的真假值确定，即使表达式中还有部分尚未校验，整个评估工作仍然直接结束。而函数调用语义下所有表达式均要执行。 表达式中若含有,， 则逗号左侧会被先评估，然后是逗号右侧，最后表达式的结果以右侧的返回值为代表，而重载逗号时无法实现该语义。 条款8 : 了解各种不同含义的new和delete 理解: new operator, operator new和placement new : new operator在堆上生产对象，分配内存并且调用构造函数; operator new只分配内存（不一定在堆上），不调用构造函数； placement new在分配好的内存上调用构造函数。 delete operator和operator delete: delete operator析构并且释放内存； operator delete仅释放内存。 针对数组的new operator和delete operator：与单一对象相比，对数组中的每一个对象进行new和delete操作。","link":"/2021/05/13/%E3%80%8AMore-Effective-C-%E3%80%8B-%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"【读书笔记】《More-Effective-C++》-技术","text":"《More-Effective-C++》读书笔记 技术 条款25 将constructor和non-member functions虚化 virtual constructor并非是指构造函数为虚函数(也不允许)，而是指某种函数，给定不同的输入参数，返回不同的类型的对象，典型例子为clone函数，返回基类指针，指向不同的子类。 将非成员函数虚化的做法：写一个虚函数做实际多态工作，然后用非成员函数调用该虚函数。 条款26 限制某个class所能产生的对象数量 单例模式， static member。 使用一个用于计算对象个数的Base Class将统计对象个数的任务委托出去，类使用者对控制对象个数无感知，但是定义给出count上限。 条款27 要求(或禁止)对象产生于heap之中 析构函数设为private可以限制对象生成在heap中，因为私有的析构函数会使none-heap object在其生命周期结束时隐形调用的析构函数这一行为非法。但是私有析构函数这一做法会影响继承， 改为protect可以解决这一问题。 条款28 Smart Pointers(智能指针) 智能指针借助RAII技术，可以保证资源的释放，这一点比原生指针(又称dumb point)好用很多。 auto_ptr这一智能指针并不建议用，一些C++编程规范里建议不使用或禁止使用auto_ptr，而是建议使用unique_ptr和shared_ptr。 条款29 Reference counting(引用计数) 没太看懂重点在哪里。 条款30 Proxy Classes(替身类、代理类) 可以利用proxy classes类技术区分[]的读写动作，是一个lazy evaluation操作。 条款31 让函数根据一个以上的对象类型来决定如何虚化 描述了double dispatch的解决方案。 方法于虚函数实现机理类似，构建并维护不依赖应用类的第三方virtual table类，存放具体类别和对应调用函数的map数组，实现多个动态类型的虚化问题。","link":"/2021/08/09/%E3%80%8AMore-Effective-C-%E3%80%8B-%E6%8A%80%E6%9C%AF/"},{"title":"【读书笔记】《More-Effective-C++》-效率","text":"《More-Effective-C++》读书笔记 效率 条款16 谨记80-20法则 这一条款说明影响程序运行效率的代码一般只占总代码的20%，使用程序分析器分析出造成性能瓶颈的对应代码。 条款17 考虑使用lazy evaluation（缓式评估） 缓式评估的思想是延缓运算，知道必须要的时候。对于你的软件被要求执行某些计算，而那么计算其实可以避免的场景，缓式评估有一定效率提升。书中举例说明了缓式评估可以提高效率的四个场景： Reference Counting(引用计数): 避免非必要的对象复制。 区分读与写: 写操作比读操作更耗时，用缓式评估和proxy classes来区分operator[]的读与写操作。 Lazy Fetching(缓式取出): 针对读取数据库数据并实例化大对象。这样一个大数据对象往往比较耗时，则一开始只产生该对象的“外壳”，不从数据库中读取数据，直到某个字段被真正需要。 Lazy Expression Evaluation(表达式缓评估): 避免非必要的数值计算。 条款18 分期摊还预期的计算成本 与条款17不同，这一条为超急评估(over-eager evaluation)，在被要求之前就先把事情做下去。针对的场景是如果你的程序常常会用到某个计算，可以设计一份数据结构以便能够极有效率的处理需求，常见的做法有caching（数值缓存）和Prefetching(预先取出）。 条款19 了解临时对象的来源 这里说的临时对象是指没有命名的non-head object，此类的对象比较隐蔽，其对应的构造和析构函数也会对你的程序性能造成影响。书中给出了生成临时对象的常见两种场景： 函数调用时的隐形类型转换 函数返回值为一个对象(by value)，如operator+。 条款20 协助完成&quot;返回值优化(RVO)&quot; 应尽可能避免返回对象，必须要返回时以返回constructor arguements取代对象。 eg. 123456const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs){ return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());} 条款21 利用重载技术(overload)便面隐式类型转换(implict type coversions) 隐式类型转换应能避免就避免，多重载几个函数以支持多种合法type，减少隐式类型转换发生次数。 条款22 考虑以操作符复合形式(op=)取代其独身形式(op) 以op=为基础实现op。 条款23 考虑使用其他程序库 根据场景以及性能瓶颈选择合适的library。 条款24 了解virtual functions, multiple inheritance, virtual base classes, runtime type identification的成本 性质 对象大小增加 Class数据量增加 Inlining几率增加 虚函数 是 是 是 多重继承 是 是 否 虚拟基类 往往如此 有时候 否 运行时期类型辨识 否 是 否","link":"/2021/08/07/%E3%80%8AMore-Effective-C-%E3%80%8B-%E6%95%88%E7%8E%87/"},{"title":"【读书笔记】《More-Effective C++》- 杂项讨论","text":"《More-Effective-C++》读书笔记 杂项 条款32 在未来时态下发展程序 拥抱变化，架构设计时考虑未来可能的需求。 条款33 将非尾端类(non-leaf classes)设计为抽象类(abstract class) 基类抽象化。 条款34 如何在同一个程序中结合C++和C 保证C++和C编译出来的目标文件相互兼容 将双方都使用的函数声明为extern &quot;C&quot; 尽量在c++中写main函数(因为考虑static变量初始化的迁移性) 总是以delete删除new返回的内存，以free释放malloc的内存 涉及数据传递时，将数据结构设计为C能接受的形式 条款35 让自己习惯于标准C++语言 拥抱新特性吧～～","link":"/2021/08/23/%E3%80%8AMore-Effective-C-%E3%80%8B-%E6%9D%82%E9%A1%B9/"},{"title":"【读书笔记】《深度探索C++对象模型》","text":"去年年底就已经看完这本书了，想着整理读书笔记一直拖延到现在，体验就是没有整理出来的知识过的久了确实容易忘记。 第1章 关于对象 C++相对于C来说，在布局以及存取时间上的主要的额外负担是由virtual引起的。 三种对象模型: 简单对象模型：member本身不放在object之中，只有“指向member的指针”才放在object内。该模型没有用在实际产品上。 表格驱动对象模型：将class object拆分成data member table和member function table，class object存放指向这两个table的指针。该模型没有用在实际产品上。 C++对象模型：Nonstatic data members放在每一个class object之内，static data members，static/nonstatic function members则存放在个别的class object之外。 virtual function的实现机制: 每个class产生一组指向该class的virtual functions的指针，存放在一个virtual table里（vtbl） 每个class object有一个指针（vptr）指向相关的virtual table。vptr的设定和重置由class的constructor, destructor和copy assignment运算符自动完成。vtbl的第一个slot通常是class关联的type info object（用来支持runtime type identification） class对象占用的内存: nonstatic data members的总和大小 内存对齐损耗 因支持virtual function产生的内存损耗 第2章 构造函数语义学 以下四种情况，编译器会为未提供默认构造函数的类合成默认构造函数： 带有Default Constructor的Member class Object：类的成员变量有其他类，并且该类有默认构造函数； 带有Default Constructor的Base Class：有父类，父类有默认构造函数； 带有一个Virtual Function的Class：有虚函数； 带有一个Virtual Base Class的Class：有虚基类; 编译器合成的默认构造函数并不会给nonstatic data member（如整数，整数指针，整数数组等）初始化！！！ 成员初始化列表： 初始化顺序是按照成员变量的声明顺序初始化的，编译器优化之后的顺序与成员列表的顺序不一定一致； 成员初始化的code会放在实际code之前。 第3章 Data语意学 一个virtual base class subobject只会在derived class中存在一份实例，不管它在class在继承体系中出现了多少次。 static data member存放在程序的数据段里，nonstatic data members存放在class实例里。 第4章 Function语意学 name mangling的做法编译器并不统一，即生成的名字规范都不一致。编程中link出错的时候报出的奇奇怪怪的函数名其实就是经过name mangling的名字。 static member function没有this指针： 不能直接存取其class的nostatic members; 不能声明成const, volatile或者virtual; 不需要class object就能调用。 一个class只会有一个virtual table，virtual table中含有以下active virtual functions: 该class定义的virtual function; 继承自base class的virtual function; 一个pure_virtual_called()函数实例。 第5章 构造，析构，拷贝语意学 object生命周期: local object从定义到退出其scope； global object存活整个程序周期； heap object从new开始到delete结束。 vptr初始化的时间为base class constructors调用结束之后，程序员代码或者member initialization list之前。 以下情况下，class对默认的copy assignment operator不会表现出bitwise copy语意，即默认的拷贝赋值函数不太行: 当class含有一个member object; 当class的base class有一个拷贝赋值函数； 当class声明里任何virtual function； 当class继承一个virtual base class。 析构函数的实际顺序 析构函数本体； 如果class有member class object且拥有析构函数，则按照声明顺序相反顺序调用； 如果有vptr, 需要被重新设定，指向base class的virtual table; 如果有任何直接nonvirtual base classes拥有析构函数，会按照声明顺序的相反顺序调用； 如果有任何virtual base classes拥有析构函数，并且当前class为最末端的class, 则会按照原来构造的顺序的反顺序被调用。 第6章 执行期语意学 编程规范中建议object使用时才定义是因为可以节省非必要的对象产生和摧毁操作。比如说一个object先定义了，但其实后面并没有用到，编译生成的代码其实在定义出就产生了其构造，后面跳出scope又要产生其析构代码，这部分代码是冗余代码。 new运算符： 配置内存； 在配置的内存处构造object，赋初值。 第7章 站在对象模型的尖端 Template不好用，容易出错，debug麻烦，对编程人员要求很高。 Template函数中涉及类型相关的校验，延迟到实例化操作时才发生。 发生exception时，编译器会做如下操作： 检验发生throw的操作的函数； 决定throw操作是否发生在try区段中； 若是，把exception type拿来和每一个catch子句进行比较； 如果匹配，流程控制交到catch子句中； 如果throw操作没有发生在try区域或者没有匹配到catch子句，编译器需要(a)摧毁所有active local object(b)将目前的函数从堆栈中unwind掉©进入函数调用栈下一个函数中，重复步骤2-5。 对一个class指针进行dynamic_cast： 如果操作成功，则会返回真正的地址； 否则返回0，便是没有cast成功。","link":"/2022/03/01/%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/"},{"title":"【算法模板】二分查找","text":"1 问题描述 二分算法首先前提是数组是有序的，时间复杂度 O(log(n)), 难点主要在于边界条件的判断. 现在整理了一下边界条件以及模板代码. 区间取左闭右开区间. while 判断条件为 &lt; . mid = left + (right - left) / 2. 2 代码模板 代码模板语言为Java, 尽量不使用语法糖，转换成其他语言方便. 12345678910111213141516public int binarySearch (int[] arr, int target) { int left = 0; int right = arr.length; // 这里取不到right, 为开区间 int mid = 0; while (left &lt; right) { mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; }else if (arr[mid] &gt; target) { right = mid; // 以递增为例，缩小查找区间至[left, mid) }else { left = mid + 1; // [mid + 1, right) } } return -1;} 3 相关例题 LeetCode 34. Find First and Last Position of Element in Sorted Array LeetCode 69. Sqrt(x) LeetCode 74. Search a 2D Matrix LeetCode 153. Find Minimum in Rotated Sorted Array","link":"/2019/06/23/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"title":"【算法模版】哈希算法","text":"Hash 算法介绍 一种映射关系，关键字到存储地址的映射，会存在hash 碰撞的情况发生 解决Hash 碰撞的常用方法 开放定址法（再散列法） 当关键字key的Hash 地址p = H(key) 冲突时， 以p 为基础产生另一个Hash 地址p1，如果p1 仍冲突，再以p 为基础产生一个Hash 地址p2, 直到产生不冲突的Hash 地址pi. 1Hi = (H(key) + di) % m, i = 1, 2, ..., n 线性探测再散列 发生Hash 碰撞时顺序查看表中下一单元，直到找到一个空单元或查遍全表. 二次探测再散列 发生Hash 碰撞时在表的左右跳跃式探测 伪随机探测再散列 依据产生的伪随机序列以给定随机数为起点做探测. 再Hash 法 构造多个Hash 函数，发生碰撞时换用Hash 函数，直到冲突不再发生. 链地址法 将Hash 地址相同的元素构成一个称为同义词链的单链表. 建立公共溢出区 将Hash 表分为基本表和溢出表两部分，与基本表冲突的元素放入溢出表.","link":"/2019/08/05/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"title":"【算法模板】并查集","text":"并查集 1 概念介绍 在计算机科学中，并查集是一种树形结构，用来处理不交集(Disjoint Sets)得合并和查询问题[1]。并查集主要是有两个操作，依次是： Find : 查找 Union ：合并 其中Find是判断给定元素属于哪一类别，常用一组类别中某个元素作为Root元素，表征这一类别，那么Find操作其实就是这个元素对应的Root值为多少。两个元素的Root值相同，则该两个元素为同一类别。 在构建并查集时，会遇到将两个类别合并为一个类别，即为Union。按上述对于Find操作的描述，即将原两个类别中所有元素对应的Root值改成同一值。 2 代码模板 2.1 朴素并查集 不考虑效率，从定义上实现并查集Find和Union两个操作。核心点就是用一个p数组维护该元素的父节点元素值或Root值(路径压缩)，当一个元素的p值为其本身时，则该节点为Root节点。 其中p值为元素对应的Root时并查集效率更高，以下模板给出了这种情况下的算法实现。 1234567891011121314151617181920212223242526void MakeSet(int size){ // 初始化并查集，将每个元素的p值设置为其本身 // 假设节点值是1~size(含size) for (int i = 1; i &lt;= size; i++) { p[i] = i; }}int Find(int n){ // 判断元素n的类别，即查找元素n的Root元素值 if (p[n] != n) { p[n] = Find(p[n]); // 非Root节点，继续向上查找，并赋值 } return p[n];}void Union(int n, int m){ // 将元素n和元素m所在类别合并 // 只需将n和m中的一个元素的Root指向另一个元素的Root int rootA = Find(n); int rootB = Find(m); p[rootA] = rootB; // n的Root指向m的Root} 2.2 维护元素集Size的并查集 与朴素并查集算法实现不用的是，这里维护了一个size数组保存每个类别中的当前的元素数量，预设只有Root节点的size数组值才有效。 1234567891011121314151617181920212223242526272829303132void MakeSet(int size){ // 初始化并查集，将每个元素的p值设置为其本身 // 假设节点值是1~size(含size) for (int i = 1; i &lt;= size; i++) { p[i] = i; // ! 增加size数组 size[i] = 1; }}int Find(int n){ // 判断元素n的类别，即查找元素n的Root元素值 // ! Find操作是不需更新size数组 if (p[n] != n) { p[n] = Find(p[n]); // 非Root节点，继续向上查找，并赋值 } return p[n];}void Union(int n, int m){ // 将元素n和元素m所在类别合并 // 只需将n和m中的一个元素的Root指向另一个元素的Root int rootA = Find(n); int rootB = Find(m); p[rootA] = rootB; // n的Root指向m的Root // ! rootB为新的Root, 只需更新rootB的size值 size[rootB] += size[rootA];} 2.3 维护元素到root节点距离的并查集 用一个数组维护当前元素到root节点的距离。 123456789101112131415161718192021222324252627282930void MakeSet(int size){ // 初始化并查集，将每个元素的p值设置为其本身 // 假设节点值是1~size(含size) for (int i = 1; i &lt;= size; i++) { p[i] = i; w[i] = 0; // 默认每个节点的root节点为其本身，故w值默认为0 }}int Find(int n){ // 判断元素n的类别，即查找元素n的Root元素值 if (p[n] != n) { int \bnum = Find(p[n]); w[n] += w[num]; // 更新当前节点的w值 p[n] = num; // 非Root节点，继续向上查找，并赋值 } return p[n];}void Union(int n, int m){ // 将元素n和元素m所在类别合并 // 只需将n和m中的一个元素的Root指向另一个元素的Root int rootA = Find(n); int rootB = Find(m); p[rootA] = rootB; // n的Root指向m的Root w[rootA] = distnace; // 具体情况具体分析} 相关leetcode例题 LeetCode并查集专题 [1] 并查集-维基百科 [2] 并查集 OI Wiki","link":"/2021/05/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"【算法模版】排序算法总结","text":"1 时间复杂度与空间复杂度 算法 稳定性 时间复杂度 空间复杂度 备注 选择排序 false O(N**2) O(1) 冒泡排序 true O(N**2) O(1) 插入排序 true O(N) ~ O(N**2) O(1) 时间复杂度与初始顺序有关 希尔排序 false N 的若干倍乘递增序列的长度 O(1) 改进版的插入排序 快速排序 false O(NlogN) O(logN) 三向切分快速排序 false O(N) ~ O(NlogN) O(logN) 适用有大量重复主键 归并排序 true O(NlogN) O(N) 堆排序 false O(NlogN) O(1) 无发利用局部性原理 2 具体算法 2.1 选择排序 算法描述: 从数组中选择最小/大元素，与第一个元素交换位置。再从数组剩下的元素中选择最小/大的元素，与第二个元素交换位置。直到整个数组排序完成。 code: 123456789101112131415public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; { @Override public void sort(T[] nums) { int N = nums.length; for (int i = 0; i &lt; N - 1; ++ i) { int min = i; for (int j = i + 1; j &lt; N; ++ j) { if (less(nums[j], nums[min])) { min = j; } } swap(nums, i, min); } }} 2.2 冒泡排序 算法描述: 从左到右不算交换相邻逆序的元素，经过一轮循环之后，可以让未排序的的最大元素上浮到右侧。在一轮循环中如果没有发生交换，则说明数组是有序的，此时可以直接退出。 code: 12345678910111213141516public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; { @Override public void sort(T[] nums) { int N = nums.length; boolean isSorted = false; for (int i = N - 1; i &gt; 0 &amp;&amp; !isSorted; -- i) { isSorted = true; for (int j = 0; j &lt; i; ++ j) { if (less(nums[j + 1], nums[j])) { isSorted = false; swap(nums, j, j + 1); } } } }} 2.3 插入排序 算法描述: 每次都将当前元素插入到左侧已经排序的数组中，维护左侧数组排序 code: 123456789101112public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; { @Override public void sort(T[] nums) { int N = nums.length; for (int i = 1; i &lt; N; ++ i) { for (int j = i; j &gt; 0 &amp;&amp; less(nums[j], nums[j - 1]); -- j) { swap(nums, j, j - 1); } } }} 2.4 希尔排序 算法描述: 插入算法的优化 code: 1234567891011121314151617181920public class shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; { @Override public void sort(T[] nums) { int N = nums.length; int h = 1; while (h &lt; N / 3) { h = 3 * h + 1; // 间隔 } while (h &gt;= 1) { for (int i = h; h &lt; N; ++ i) { for (int j = i; j &gt;= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) { swap(nums, j, j - h); } h = h / 3; } } }} 2.5 快速排序 算法描述: 选择一个元素将数组切分，元素左边都小于等于这个元素，右边都大于等于, 然后子数组递归 code: 123456789101112131415161718192021222324252627282930public class QuickSort&lt;T extends Comparable&lt;T&gt;&gt; entends Sort&lt;T&gt; { @Override public void sort(T[] nums) { sort(nums, 0, nums.length - 1); } private void sort(T[] nums, int l, int r) { if (l &gt;= r) return; int m = partition(nums, l, r); sort(nums, l, m - 1); sort(nums, m + 1, r); } private int partition(T[] nums, int l, int r) { T v = nums[l]; while (l &lt; r) { while (l &lt; r &amp;&amp; less(v, nums[r])) { r --; } nums[l] = nums[r]; while ( l &lt; r &amp;&amp; less(nums[l], v)) { l ++; } nums[r] = nums[l]; } nums[l] = v; return l; }} 2.6 归并排序 算法描述: 将数组分成两部分，分别进行排序，然后归并起来 code: 1234567891011121314151617181920212223public class MergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; { @Override public void sort(T[] nums) { T[] copy = new T[nums.length]; sort(nums, copy, 0, nums.length); } private void sort(T[] nums, T[] copy, int l, int r) { if (r - l &gt; 1) { int m = l + (r - l) / 2; int p = l; // 左区间开始 int q = m; // 右区间开始 int i = l; sort(nums, copy, l, m); // 左闭右开区间 sort(nums, copy, m, r); while (p != m || q != r) { if (q &gt;= r || (p &lt; m &amp;&amp; less(nums[p], nums[q]))) copy[i ++] = nums[p ++]; else copy[i ++] = nums[q ++]; } } }} 2.7 堆排序 算法描述:","link":"/2019/08/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"【读书笔记】《More Effective C++》- 异常","text":"《More Effective C++》读书笔记 异常 条款9： 利用destructors避免泄漏资源 理解: 将一个对象存放在必须被自动释放的的资源里，并依赖该对象的destructor释放，可有效避免出现exceptions发生资源泄漏。 例如可用智能指针auto_ptr指向创建的对象，实现这一设计。 条款10: 在constructors内阻止资源泄漏（resource leak） 理解: 论述如何处理在构造函数中发生异常而导致的资源泄漏，即用auto_ptr对象代替pointer class members对象，无须在析构函数中手动释放资源。 条款11: 禁止异常（exceptions）流出destructors之外 理解: 论述了析构函数内发生的异常必须要在其函数内被捕捉到的两个原因： （1）可以避免terminate函数在exceptions传播过程中的栈展开（stack-unwinding）机制中被调用。如果控制权基于exception的因素离开destructor，而此时正有另一个exception处于作用状态，c++会调用terminate函数。 （2）可以确保destructor完成其应该完成的所有事情。 条款12: 了解“抛出一个exception”与“传递一个参数”或“调用一个虚函数”之间的差异。 理解: 主要有三个差异 （1）exception objects总是会被复制，如果是以by value方式捕捉，会被复制两次。 （2）“被抛出成为exception”的对象，允许的类型转换比“传递到函数去”的对象少。“exception与catch子句相匹配”的过程中，只支持两种类型转换，一种是继承体系中的类转换（基类可以捕捉到子类），二是从一个“有型指针”转为“无型指针”（针对const void*指针设计的catch子句，可以捕捉到任何指针类型的exception）。 （3）catch 子句匹配的机制是“first fit”。 条款13: 以by reference方式捕捉exceptions 理解: 论述了by pointer，by value以及by reference三种方式传递异常给catch的优劣，最后得出结论是以by reference方式，原因概要如下： （1）以by pointer方式传递需要考虑传递过来的对象的删除问题，比较难处理，有的时候需要删除，有的时候不需要。 （2）以by value方式会出现切割问题，即用基类捕捉到了子类的异常对象，会丢失子类的派生成分，其实就是变成了子类对象。在调用虚函数的时候，仍然只会调用基类的函数而不是子类的函数。 条款14: 明智运用exception spectifications 理解: exceptions specifications不太好使。 条款15: 了解异常处理（exception handling）的成本 理解: 只要能够不支持exception，编译器便不支持。 斤可能不用try语句块和exception specification，因为那样会使代码膨胀。","link":"/2021/05/15/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AMore-Effective-C-%E3%80%8B-%E5%BC%82%E5%B8%B8/"},{"title":"【算法模板】快速排序","text":"1234567891011121314151617181920void QuickSort(int nums[], int left, int right){ if (left &gt;= right) { return; } int l = left - 1; int r = right + 1; int midVal = nums[left + right &gt;&gt; 1]; while (l &lt; r) { do l++; while (nums[l] &lt; midVal); do r--; while (nums[r] &gt; midVal); if (l &lt; r) { Swap(nums, l, r); } } QuickSort(nums, left, r); QuickSort(nums, r + 1, right);}","link":"/2021/05/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"电子书资源分享（持续更新...)","text":"1 算法相关 算法导论(原书第3版) 中文完整版 高清扫描版.pdf, 提取码: 9udh 2 Java Java核心技术 卷2 高级特性 原书第10版, 提取码: 3tcg 3 其他 阿里巴巴Java开发手册1.4.0, 提取码: il1h","link":"/2019/06/24/%E7%94%B5%E5%AD%90%E4%B9%A6%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"title":"项目踩坑记录","text":"POJO 对象的setter 和getter 方法都得有","link":"/2019/07/04/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"【算法模版】高精度运算","text":"简介 高精度计算也是常见典型例题之一，其解题思路概括来说就是按位来进行加减乘除，将大数拆解为数组来处理。现依次给出高精度加法，高精度减法，高进度乘法和高精度除法的算法模版。 1 高精度加法 123456789101112131415161718vector&lt;int&gt; BigAdd(const vector&lt;int&gt;&amp; num1, const vector&lt;int&gt;&amp; num2){ // num1，num2倒序存数据，eg.原数据为123，num1为{3, 2, 1} vector&lt;int&gt; sum; int add = 0; // 存放进位 int maxSize = max(num1.size(), num2.size()); for (int i = 0; i &lt; maxSize || add; i++) { if (i &lt; num1.size()) { add += num1[i]; } if (i &lt; num2.size()) { add += num2[i]; } sum.push_back(add % 10); add /= 10; } // sum 倒序存结果 return sum;} 题目: 高精度加法 2 高精度减法 1234567891011121314151617181920212223vector&lt;int&gt; BigMinus(const vector&lt;int&gt;&amp; num1, const vector&lt;int&gt;&amp; num2){ // 倒序存数据，个位数在首位 vector&lt;int&gt; minus; int m = 0; for (int i = 0; i &lt; num1.size(); i++) { m = num1[i] - m; if (i &lt; num2.size()) { m -= num2[i]; } minus.push_back((m + 10) % 10); // 这一步操作有点东西 if (m &lt; 0) { m = 1; } else { m = 0; } } // 去除前导0 while (minus.size() &gt; 1 &amp;&amp; minus.back() == 0) { minus.pop_back(); } return minus;} 高精度乘法 1234567891011121314151617181920vector&lt;int&gt; BigMulti(const vector&lt;int&gt;&amp; num1, const vector&lt;int&gt;&amp; num2){ vector&lt;int&gt; multi(num1.size() + num2.size(), 0); for (int i = 0; i &lt; num1.size(); i++) { for (int j = 0; j &lt; num2.size(); j++) { multi[i + j] += num1[i] * num2[j]; } } int n = 0; for (int i = 0; i &lt; multi.size(); i++) { n += multi[i]; multi[i] = n % 10; n /= 10; } // 去除前导0 while (multi.size() &gt; 1 &amp;&amp; multi.back() == 0) { multi.pop_back(); } return multi;} 题目 高精度乘法","link":"/2021/07/28/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"},{"title":"【读书笔记】《More Effective C++》- 基础议题","text":"《More Effective C++》读书笔记 基础议题 条款1 : 仔细区别pointer和references 理解：指针和引用有相似的地方，都可以间接参考操作其他对象，但因二者存在区别，而这区别也是使用指针还是引用时的重要依据。详细展开来说如下： 引用必须初始化，并且总是指向最初赋值的那个对象，不能改变。 这一点引用限制比指针多，指针可赋值为null,可改变指向，更加灵活。除非程序中指向性不变（合适引用），否则指针的灵活性更高，更加适合。 另外一种书中提到实现某些操作符，特别地必须返回某种能够被当作assignment赋值对象地东西,以[]为例，该种情况下使用引用。 个人理解该种情况区分度较高，若是[]返回值为指针类型，则会出现如下情况1234567vector&lt;int&gt; num(10);// [] 返回值类型为引用，目前stl实现num[0] = 1;// [] 返回值类型为指针, 会造成这是个指针vector的误解*num[0] = 1; 条款2 : 最好使用C++转型操作符 理解：编程中尽量不要使用类型转换，计算使用，也不用C格式的类型转换，即：(type) expression C++提供了四个新型转型操作符，使用方法为xxx_cast&lt;type&gt;(expression)： static_cast : 与C格式的类型转换符作用基本一致 const_cast : 改变常量性和变易性，最常见用途是将某个对象的常量性去除掉。（即移除const属性） dynamic_cast : 继承体系中安全的向下转型或跨系转型动作，即将指向基类的指针或者引用转换成指向派生类的指针或者对象。 reinterpret_cast : 用来转换函数指针类型，与编译平台强相关，尽量不用。 条款3 : 绝对不要以多态的方式处理数组 理解: 数组对象几乎总是会涉及指针的算术运算，而多态和指针算术不能混用。 条款4 : 非必要不提供default constructor 理解: 某些类初始化需要提供参数，若为了使用类便利提供了default constructor, 则会导致部分字段无意义，反而造成软件质量下降。","link":"/2021/05/13/%E3%80%8AMore-Effective-C-%E3%80%8B-%E5%9F%BA%E7%A1%80%E8%AE%AE%E9%A2%98/"},{"title":"优质博客分享(持续更新)","text":"优质博客记录以及分享 高并发系统之限流特技 动态链接库中函数的地址确定—PLT和GOT Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈 Redis和Memcached的区别 epoll内核源码详解+自己总结的流程 后台开发面试问题整理 Linux内核：poll机制 linux任务调度机制 解读Raft（一 算法基础） - 杭州.Mark - 博客园 Linux文件系统详解 - AlanTu - 博客园 Linux c 开发 - 内存管理器ptmalloc - CSDN博客 Linux环境变量及其设置 - CSDN博客 比较全面的gdb调试命令 - 知识天地 - 博客园 把握linux内核设计思想（六）：内核时钟中断 - CSDN博客 Linux进程调度原理 - alex.shu - 博客园 Linux系统调用的实现机制分析 - CSDN博客 理解inode - 阮一峰的网络日志 多阶hash表 - juary_的专栏 - CSDN博客 理解 glibc malloc - CSDN博客 Redis与Memcached的比较-zpf1218-ChinaUnix博客 glibc中malloc的详细解释 - CSDN博客 Redis的那些最常见面试问题 - 回首笑人间 - 博客园 浅析基于glibc的malloc - CSDN博客 slab机制 - wangLinuxer - 博客园 有感于STL的内存管理 DNS使用的是TCP协议还是UDP协议 - qq100440110的专栏 - CSDN博客 Linux的任务调度机制 - Nicholas的专栏 - CSDN博客 进程—内存描述符（mm_struct） - CSDN博客 彻底弄懂HTTP缓存机制及原理 - 木上有水 - 博客园 利用CAS操作（Compare & Set）实现无锁队列 - CSDN博客 进程间通信的方式——信号、管道、消息队列、共享内存 - 0giant - 博客园 TCP的数据流——滑动窗口，拥塞窗口，慢启动，Nagle算法，经受时延的确认等 - 千里之外 - CSDN博客 TCP协议总结--停止等待协议,连续ARQ协议,滑动窗口协议 - 杨博东的博客 - 博客园 C/C++ 笔试、面试题目大汇总 - fangyukuan - 博客园 C/C++ 内存对齐原则及作用 - chy19911123的专栏 - CSDN博客 mysql数据库面试总结 - bullets - 博客园 [学习笔记]数据库设计三大范式与BCNF，学习笔记 - ybwang1989 - 博客园 常见面试题整理--数据库篇（每位开发者必备） - weinierzui的专栏 - CSDN博客 知识库 - 你身边的技术百科全书 - CSDN 进程上下文与线程上下文 - bingshanyijiao_fkx的专栏 - CSDN博客 linux线程切换和进程切换的方法_Linux_脚本之家 深入理解计算机系统之虚拟存储器 - Al_xin的专栏 - CSDN博客 tcp的半连接与完全连接队列 - go4it - 简书 数位dp总结 之 从入门到模板 - 努力 - CSDN博客 类中函数的重载、隐藏和覆盖 - beaglebone - 博客园 排序算法____基数排序 - Dingwj_blog - 博客园 面试题干货在此_讨论区_牛客网 排序算法系列：基数排序 - 大鱼 - CSDN博客 位图索引:原理（BitMap index） - zhanlijun - 博客园 fopen与open的区别 - 清清飞扬 - 博客园 《深入理解计算机系统》-虚拟存储器 - gatsby_dhn - 简书 Linux内核解析:进程间通信：管道 - 笨拙的菜鸟 - 博客园 参考别人的面试总结：linux C/C++服务器后台开发面试题总结 - 大孟的博客 - CSDN博客 linux C/C++服务器后台开发面试题总结 - Nancy26 - 博客园 ELF 文件中的section 和 segment - wo_der的博客 - CSDN博客 聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT - 海枫的专栏 - CSDN博客 ELF文件的加载和动态链接过程 - - ITeye博客 ELF文件的加载过程(load_elf_binary函数详解)--Linux进程的管理与调度（十三） - AderStep - CSDN博客 linux awk命令详解 - ggjucheng - 博客园 IP分片和TCP分片的区别 - cumirror的专栏 - CSDN博客 fork()----父子进程共享 - 程序狗的成长之路 - CSDN博客 Makefile中的wildcard用法 - liangkaiming的专栏 - CSDN博客 深入理解C++的动态绑定和静态绑定 - 常高伟的专栏 - CSDN博客 C++模板元编程（C++ template metaprogramming） - 文章 - 伯乐在线 C++后台开发校招面试常见问题 - oscarwin - CSDN博客 互斥锁的实现（转） - hzhzh007的专栏 - CSDN博客 TCP-IP详解：糊涂窗口综合症（Silly Window syndrome） - 深邃 精致 内涵 坚持 - CSDN博客 浅析Linux下的task_struct结构体 - qq_29503203的博客 - CSDN博客 C++虚继承的概念 - crystal_avast的专栏 - CSDN博客 c++ 虚继承与继承的差异 - Kikim的地盘 - CSDN博客 Linux的inode的理解 - iTech - 博客园 IPC通信:Posix消息队列 - liuhongxiangm的专栏 - CSDN博客 Linux线程的信号量同步 - JollyWing - 博客园 Linux进程间通信——使用共享内存 - ljianhui的专栏 - CSDN博客 gdb调试coredump(使用篇) - 叶落无痕，枫过有情…… - CSDN博客 信号中断 与 慢系统调用 - 许振坪的专栏 - CSDN博客 浅析CPU中断技术 - Funeral - 博客园 Linux信号（signal) 机制分析 - h13 - 博客园 EPOLLIN , EPOLLOUT , EPOLLPRI, EPOLLERR 和 EPOLLHUP事件 - yingying.liu的专栏 - CSDN博客 三种工厂模式的分析以及C++实现 - 曾经的你| - 博客园 STL源码剖析---红黑树原理详解上 - Hackbuteer1的专栏 - CSDN博客 valgrind 的使用简介 - sduliulun的专栏 - CSDN博客 _unix linux_脚本之家 GDT(Global Descriptor Table)全局描述符表 - starlitnext - 博客园 Linux程序加载过程 - 赢在拼搏中 - CSDN博客 linux 用户空间与内核空间——高端内存详解 - 立超的专栏 - 博客园 Linux虚拟地址空间布局以及进程栈和线程栈总结 - wilcohuang's blog - CSDN博客 堆排算法的分析与总结 - HOU_JUN - 博客园 HTTP必知必会——常见面试题总结 - Leeon的博客 - CSDN博客 pthread_once单例模式 - tom555cat - CSDN博客 pthread_once()使用（某个时间在整个程序中仅执行一次，不确定是那个线程） - 轻飘飞扬 - CSDN博客 23种设计模式对比与总结 - 码农恋码 - 博客园 ORM框架使用优缺点 - public - CSDN博客 高性能服务开发之定时器 - 行健 - 博客园 Https协议详解 - CoderZhuang - 博客园 图解SSL/TLS协议 - 阮一峰的网络日志 HTTPS 原理解析 - Zery - 博客园 Linux的用户和用户组管理 - 风生水起 - 博客园 TCP系列13—重传—3、协议中RTO计算和RTO定时器维护 - lshs - 博客园 可执行文件（ELF）格式的理解 - 深海的小鱼儿 - 博客园 GCC/G++编译参数含义 - yasi_xi的专栏 - CSDN博客 Linux内核中cache的实现 - leopard_ray的专栏 - CSDN博客 epoll源码实现分析[整理] - Apprentice89 - 博客园 linux内核内存管理学习之三（slab分配器） - 浩海拾贝 - CSDN博客 深度理解select、poll和epoll - 傻眼哥的博客 - CSDN博客 【经典算法】——KMP，深入讲解next数组的求解 - c_cloud - 博客园 Linux中断（interrupt）子系统之一：中断系统基本原理 - DroidPhone的专栏 - CSDN博客 HTTP Session、Cookie机制详解 - 奔跑的001 - 博客园 HttpSession详解 - 别再顺其自然 - 博客园 HTTP的长连接和短连接 - 烛秋 - 博客园 自动化构建 - 百度 linux内核之进程的基本概念(进程，进程组，会话关系） - 笨拙的菜鸟 - 博客园 Linux--进程组、会话、守护进程 - Alex_Monkey - 博客园 银行家算法学习笔记 - 唯心不易 - 博客园 linux session 浅谈 - younghongjian的专栏 - CSDN博客 Linux-进程、进程组、作业、会话、控制终端详解 - John_ABC - 博客园 关系型数据库到文档型数据库的跨越 - 海天一色是黑色的博客 - CSDN博客 linux系统编程之进程（八）：守护进程详解及创建，daemon()使用 - mickole - 博客园 数据库设计三大范式 - Ruthless - 博客园 常见面试题整理--数据库篇 - 铭记遗忘 - 博客园 谈谈数据库的ACID - 敦格 - CSDN博客 关于TCP乱序和重传的问题 - cws1214的专栏 - CSDN博客 DNS 原理入门 - 阮一峰的网络日志 数据结构专题——线段树 - MetalSeed - CSDN博客 一步一步理解线段树 - tenos - 博客园 mysql 数据表读锁机制详解 - joy696163 - 博客园 单例模式全面学习（C++版） - weixliu - 博客园 单例模式及C++实现代码 - 曾经的你| - 博客园 每天进步一点点——五分钟理解一致性哈希算法(consistent hashing) - Cynric 的博客 - CSDN博客 TCP 协议中MSS的理解-frankzfz-ChinaUnix博客 TCP/IP详解学习笔记（15）-- TCP的流量控制和拥塞控制 - newwy - 博客园 TCP/IP详解--拥塞控制 & 慢启动 快恢复 拥塞避免 - losbyday - 博客园 关于C++中公有继承、私有继承、保护继承的讨论 - This is bill的专属博客 - CSDN博客 解决Hash碰撞冲突方法总结 - zeb_perfect的专栏 - CSDN博客 Linux进程通信之POSIX共享内存 - anonymalias的专栏 - CSDN博客 IPC对象持续性 - xiaohuima_dong的专栏 - CSDN博客 Linux环境进程间通信（三）：消息队列-hnsyspc-ITPUB博客 Linux进程同步之POSIX信号量 - anonymalias的专栏 - CSDN博客 进程/线程同步的方式和机制，进程间通信 - Icnblog_Wan - 博客园 Linux进程同步之记录锁（fcntl） - jlins - 博客园 Linux 伙伴算法简介 - 浩天之家 - 博客园 孤儿进程与僵尸进程[总结] - Anker's Blog - 博客园 Linux虚拟地址空间布局以及进程栈和线程栈总结 - Xzzzh - 博客园 linux 内核poll/select/epoll实现剖析 - 在思考的路上 - ITeye博客 Linux虚拟地址空间布局 - clover_toeic - 博客园 HTTP详解(1)-工作原理 - guisu，程序人生。 逆水行舟，不进则退。 - CSDN博客 epoll简介及触发模式（accept、read、send） - 留下的只是回忆 - 博客园 linux内核分析笔记----中断和中断处理程序 - ☆&寒 烟☆ - 博客园 标准IO与文件IO 的区别 - big_bit的博客 - CSDN博客 硬中断和软中断 - zhangskd的专栏 - CSDN博客 可重入和不可重入 - wenhui_的专栏 - CSDN博客 浅谈数位DP - zbtrs - 博客园 C++ Queues(队列)、Priority Queues(优先队列) - 面对现实，超越自己 - C++博客 缓存淘汰算法--LRU算法 - 小程故事多 - ITeye博客 Linux内核中内存cache的实现-yfydz-ChinaUnix博客 socket编程中write、read和send、recv之间的区别 - petershina的专栏 - CSDN博客 彻底学会使用epoll(六)——关于ET的若干问题总结 - feeman的专栏 - CSDN博客 linux系统编程之进程（八）：守护进程详解及创建，daemon()使用 - mickole - 博客园 Linux IO模式及 select、poll、epoll详解 - 人云思云 - SegmentFault select、poll、epoll之间的区别总结[整理] - Anker's Blog - 博客园 树状数组彻底入门 - 半根毛线 - 博客园 C++的new、delete及其内存管理 - Kelvin_Yan的专栏 - CSDN博客 malloc 函数详解 - Commence - 博客园 浅谈数据库查询优化的几种思路 - 六尺帐篷 - 简书 硬中断与软中断的区别_Linux编程_Linux公社-Linux系统门户网站 信号的基本概念、信号的产生以及阻塞信号 - 滴巴戈 - 博客园 Linux信号（signal) 机制分析 - h13 - 博客园 linux中断--LINUX中断机制与信号 - 鱼思故渊的专栏 - CSDN博客 进程线程及堆栈关系的总结 - echoisland的专栏 - CSDN博客 栈帧之深入理解c函数调用过程 - jelly_9的博客 - CSDN博客 【经典数据结构】B树与B+树 - vincently - 博客园 linux 物理内存和虚拟内存 - 百度 C/C++函数调用过程分析 - as_ - 博客园 胜者树与败者树 - whz_zb的专栏 - CSDN博客 Epoll详解及源码分析 - 我有我的天空 - CSDN博客 环回地址 - 百度 拓扑排序的原理及其实现 - dm_vincent的专栏 - CSDN博客 Manacher算法--O（n）回文子串算法 - xuanflyer - CSDN博客 【转】二叉树、B树、B-树、B+树、B*树 - zhzhang - 博客园 设计模式 之 单例模式 (C++ 懒汉经典实现 & DCL实现 & 饿汉经典实现) - 柠檬不加糖的博客 - CSDN博客 C++中的单例模式 - Hackbuteer1的专栏 - CSDN博客 【C/C++】对于可重入、线程安全、异步信号安全几个概念的理解 - ZhangPY的专栏 - CSDN博客 B树、B-树、B+树、B*树详解（转） - 憨熊之家 - 博客园 红黑树(一)之 原理和算法详细介绍 - 如果天空不死 - 博客园 分布式锁的三种实现方式 - - ITeye技术网站 平衡二叉树详解 - zhangbaochong - 博客园 n个数中任意两个异或最大值","link":"/2021/08/23/%E4%BC%98%E8%B4%A8%E5%8D%9A%E5%AE%A2%E5%88%86%E4%BA%AB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"}],"tags":[{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"JavaSE","slug":"JavaSE","link":"/tags/JavaSE/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"随手记","slug":"随手记","link":"/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"搜索算法","slug":"搜索算法","link":"/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"},{"name":"边界条件","slug":"边界条件","link":"/tags/%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6/"},{"name":"算法模板","slug":"算法模板","link":"/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"},{"name":"面试题目总结","slug":"面试题目总结","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"算法模版","slug":"算法模版","link":"/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"name":"资源","slug":"资源","link":"/tags/%E8%B5%84%E6%BA%90/"},{"name":"在线秒杀项目","slug":"在线秒杀项目","link":"/tags/%E5%9C%A8%E7%BA%BF%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Tips","slug":"Tips","link":"/categories/Tips/"}]}