{"pages":[{"title":"about","text":"蒋大志","link":"/about/index.html"},{"title":"All tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"【随手记】UML类图","text":"UML类图 1 引言 UML类图是软件方案设计中常用的一种方式，之前一直对于类之间的关系认识存在模糊，借着整理项目架构之便将该知识点规整之下。 UML类图建模中类于类之间的关系有6种，按照关系从弱到强依次是依赖(Dependency)，关联(Association)，聚合(Aggregation)，组合(Composition)，实现(Realization)和泛化(Generlization)。 2 关系概述 关系名称 解释 代码表现 图形形状 依赖 最弱的关系，一种使用的关系，即A类实现需要B类的协助 局部变量，方法的参数或者对静态方法的调用 带箭头的虚线，指向被使用者，即A使用B，箭头指向B 关联 一种拥有的关系， 如老师和学生，丈夫和妻子，拥有关系可以是单向的，也可以是双向的 成员变量 带箭头的实心线（双向关联可以双箭头或者没有箭头），指向被拥有者，即A拥有B，箭头指向B 聚合 整体和部分的关系，部分可以脱离整体单独存在，如车和轮胎 成员变量 带空心菱形的实心线，菱形指向整体，即A是整体，B是部分，菱形指向A， 箭头指向B 组合 整体和部分的关系，部分不可以脱离整体单独存在，关系比聚合强一点，如公司和部门 成员变量 带实心菱形的实心线，菱形指向整体，即A拥有B，菱形指向A，箭头指向B 实现 实现类和接口的关系 类与接口 带三角箭头的虚线，箭头指向接口，即A是实现类，B是接口， 箭头指向B 泛化 继承，最强关系 继承 带三角箭头的实线，箭头指向父类，即A是父类，B是子类，箭头指向A 备注 ： 箭头指向被继承（实现/拥有/使用）或部分的那个类 3 图例","link":"/2022/02/08/UML%E7%B1%BB%E5%9B%BE/"},{"title":"2022读书List","text":"开个blog记录一下今年读的书，想着做过的事都所有回响。 阅读范围不止专业领域，还有感兴趣的人文社科，经管，心理学，历史， 以及哲学。 专业领域 [已完成] 1. 《程序员的自我修养-链接，装载与库》 [已完成] 2. 《深度探索C++对象模型》 [TODO] 3. 《人月神话》 经管 [已完成] 1. 《财报就像一本故事书》 [TODO] 1. 《置身事内-中国政府与经济发展》 心理学 [TODO] 1. 《非暴力沟通》","link":"/2022/03/20/2022%E8%AF%BB%E4%B9%A6list/"},{"title":"hexo 常用命令手册","text":"hexo 博客命令 hexo new &quot;blog_name&quot;: 创建博文，博文路径为./source/_posts/blog_name.md hexo g: 文件生成（generator) hexo d: 文件部署(deploy) hexo s: 本地查看博客网址 详细hexo 命令见 hexo 指令详细文档","link":"/2020/01/15/hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"},{"title":"【读书笔记】《More-Effective-C++》-技术","text":"《More-Effective-C++》读书笔记 技术 条款25 将constructor和non-member functions虚化 virtual constructor并非是指构造函数为虚函数(也不允许)，而是指某种函数，给定不同的输入参数，返回不同的类型的对象，典型例子为clone函数，返回基类指针，指向不同的子类。 将非成员函数虚化的做法：写一个虚函数做实际多态工作，然后用非成员函数调用该虚函数。 条款26 限制某个class所能产生的对象数量 单例模式， static member。 使用一个用于计算对象个数的Base Class将统计对象个数的任务委托出去，类使用者对控制对象个数无感知，但是定义给出count上限。 条款27 要求(或禁止)对象产生于heap之中 析构函数设为private可以限制对象生成在heap中，因为私有的析构函数会使none-heap object在其生命周期结束时隐形调用的析构函数这一行为非法。但是私有析构函数这一做法会影响继承， 改为protect可以解决这一问题。 条款28 Smart Pointers(智能指针) 智能指针借助RAII技术，可以保证资源的释放，这一点比原生指针(又称dumb point)好用很多。 auto_ptr这一智能指针并不建议用，一些C++编程规范里建议不使用或禁止使用auto_ptr，而是建议使用unique_ptr和shared_ptr。 条款29 Reference counting(引用计数) 没太看懂重点在哪里。 条款30 Proxy Classes(替身类、代理类) 可以利用proxy classes类技术区分[]的读写动作，是一个lazy evaluation操作。 条款31 让函数根据一个以上的对象类型来决定如何虚化 描述了double dispatch的解决方案。 方法于虚函数实现机理类似，构建并维护不依赖应用类的第三方virtual table类，存放具体类别和对应调用函数的map数组，实现多个动态类型的虚化问题。","link":"/2021/08/09/%E3%80%8AMore-Effective-C-%E3%80%8B-%E6%8A%80%E6%9C%AF/"},{"title":"【算法模板】快速排序","text":"1234567891011121314151617181920void QuickSort(int nums[], int left, int right){ if (left &gt;= right) { return; } int l = left - 1; int r = right + 1; int midVal = nums[left + right &gt;&gt; 1]; while (l &lt; r) { do l++; while (nums[l] &lt; midVal); do r--; while (nums[r] &gt; midVal); if (l &lt; r) { Swap(nums, l, r); } } QuickSort(nums, left, r); QuickSort(nums, r + 1, right);}","link":"/2021/05/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"【算法模板】并查集","text":"并查集 1 概念介绍 在计算机科学中，并查集是一种树形结构，用来处理不交集(Disjoint Sets)得合并和查询问题[1]。并查集主要是有两个操作，依次是： Find : 查找 Union ：合并 其中Find是判断给定元素属于哪一类别，常用一组类别中某个元素作为Root元素，表征这一类别，那么Find操作其实就是这个元素对应的Root值为多少。两个元素的Root值相同，则该两个元素为同一类别。 在构建并查集时，会遇到将两个类别合并为一个类别，即为Union。按上述对于Find操作的描述，即将原两个类别中所有元素对应的Root值改成同一值。 2 代码模板 2.1 朴素并查集 不考虑效率，从定义上实现并查集Find和Union两个操作。核心点就是用一个p数组维护该元素的父节点元素值或Root值(路径压缩)，当一个元素的p值为其本身时，则该节点为Root节点。 其中p值为元素对应的Root时并查集效率更高，以下模板给出了这种情况下的算法实现。 1234567891011121314151617181920212223242526void MakeSet(int size){ // 初始化并查集，将每个元素的p值设置为其本身 // 假设节点值是1~size(含size) for (int i = 1; i &lt;= size; i++) { p[i] = i; }}int Find(int n){ // 判断元素n的类别，即查找元素n的Root元素值 if (p[n] != n) { p[n] = Find(p[n]); // 非Root节点，继续向上查找，并赋值 } return p[n];}void Union(int n, int m){ // 将元素n和元素m所在类别合并 // 只需将n和m中的一个元素的Root指向另一个元素的Root int rootA = Find(n); int rootB = Find(m); p[rootA] = rootB; // n的Root指向m的Root} 2.2 维护元素集Size的并查集 与朴素并查集算法实现不用的是，这里维护了一个size数组保存每个类别中的当前的元素数量，预设只有Root节点的size数组值才有效。 1234567891011121314151617181920212223242526272829303132void MakeSet(int size){ // 初始化并查集，将每个元素的p值设置为其本身 // 假设节点值是1~size(含size) for (int i = 1; i &lt;= size; i++) { p[i] = i; // ! 增加size数组 size[i] = 1; }}int Find(int n){ // 判断元素n的类别，即查找元素n的Root元素值 // ! Find操作是不需更新size数组 if (p[n] != n) { p[n] = Find(p[n]); // 非Root节点，继续向上查找，并赋值 } return p[n];}void Union(int n, int m){ // 将元素n和元素m所在类别合并 // 只需将n和m中的一个元素的Root指向另一个元素的Root int rootA = Find(n); int rootB = Find(m); p[rootA] = rootB; // n的Root指向m的Root // ! rootB为新的Root, 只需更新rootB的size值 size[rootB] += size[rootA];} 2.3 维护元素到root节点距离的并查集 用一个数组维护当前元素到root节点的距离。 123456789101112131415161718192021222324252627282930void MakeSet(int size){ // 初始化并查集，将每个元素的p值设置为其本身 // 假设节点值是1~size(含size) for (int i = 1; i &lt;= size; i++) { p[i] = i; w[i] = 0; // 默认每个节点的root节点为其本身，故w值默认为0 }}int Find(int n){ // 判断元素n的类别，即查找元素n的Root元素值 if (p[n] != n) { int \bnum = Find(p[n]); w[n] += w[num]; // 更新当前节点的w值 p[n] = num; // 非Root节点，继续向上查找，并赋值 } return p[n];}void Union(int n, int m){ // 将元素n和元素m所在类别合并 // 只需将n和m中的一个元素的Root指向另一个元素的Root int rootA = Find(n); int rootB = Find(m); p[rootA] = rootB; // n的Root指向m的Root w[rootA] = distnace; // 具体情况具体分析} 相关leetcode例题 LeetCode并查集专题 [1] 并查集-维基百科 [2] 并查集 OI Wiki","link":"/2021/05/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"电子书资源分享（持续更新...)","text":"1 算法相关 算法导论(原书第3版) 中文完整版 高清扫描版.pdf, 提取码: 9udh 2 Java Java核心技术 卷2 高级特性 原书第10版, 提取码: 3tcg 3 其他 阿里巴巴Java开发手册1.4.0, 提取码: il1h","link":"/2019/06/24/%E7%94%B5%E5%AD%90%E4%B9%A6%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"title":"【算法模版】哈希算法","text":"Hash 算法介绍 一种映射关系，关键字到存储地址的映射，会存在hash 碰撞的情况发生 解决Hash 碰撞的常用方法 开放定址法（再散列法） 当关键字key的Hash 地址p = H(key) 冲突时， 以p 为基础产生另一个Hash 地址p1，如果p1 仍冲突，再以p 为基础产生一个Hash 地址p2, 直到产生不冲突的Hash 地址pi. 1Hi = (H(key) + di) % m, i = 1, 2, ..., n 线性探测再散列 发生Hash 碰撞时顺序查看表中下一单元，直到找到一个空单元或查遍全表. 二次探测再散列 发生Hash 碰撞时在表的左右跳跃式探测 伪随机探测再散列 依据产生的伪随机序列以给定随机数为起点做探测. 再Hash 法 构造多个Hash 函数，发生碰撞时换用Hash 函数，直到冲突不再发生. 链地址法 将Hash 地址相同的元素构成一个称为同义词链的单链表. 建立公共溢出区 将Hash 表分为基本表和溢出表两部分，与基本表冲突的元素放入溢出表.","link":"/2019/08/05/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"},{"title":"项目踩坑记录","text":"POJO 对象的setter 和getter 方法都得有","link":"/2019/07/04/%E9%A1%B9%E7%9B%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"【算法模版】高精度运算","text":"简介 高精度计算也是常见典型例题之一，其解题思路概括来说就是按位来进行加减乘除，将大数拆解为数组来处理。现依次给出高精度加法，高精度减法，高进度乘法和高精度除法的算法模版。 1 高精度加法 123456789101112131415161718vector&lt;int&gt; BigAdd(const vector&lt;int&gt;&amp; num1, const vector&lt;int&gt;&amp; num2){ // num1，num2倒序存数据，eg.原数据为123，num1为{3, 2, 1} vector&lt;int&gt; sum; int add = 0; // 存放进位 int maxSize = max(num1.size(), num2.size()); for (int i = 0; i &lt; maxSize || add; i++) { if (i &lt; num1.size()) { add += num1[i]; } if (i &lt; num2.size()) { add += num2[i]; } sum.push_back(add % 10); add /= 10; } // sum 倒序存结果 return sum;} 题目: 高精度加法 2 高精度减法 1234567891011121314151617181920212223vector&lt;int&gt; BigMinus(const vector&lt;int&gt;&amp; num1, const vector&lt;int&gt;&amp; num2){ // 倒序存数据，个位数在首位 vector&lt;int&gt; minus; int m = 0; for (int i = 0; i &lt; num1.size(); i++) { m = num1[i] - m; if (i &lt; num2.size()) { m -= num2[i]; } minus.push_back((m + 10) % 10); // 这一步操作有点东西 if (m &lt; 0) { m = 1; } else { m = 0; } } // 去除前导0 while (minus.size() &gt; 1 &amp;&amp; minus.back() == 0) { minus.pop_back(); } return minus;} 高精度乘法 1234567891011121314151617181920vector&lt;int&gt; BigMulti(const vector&lt;int&gt;&amp; num1, const vector&lt;int&gt;&amp; num2){ vector&lt;int&gt; multi(num1.size() + num2.size(), 0); for (int i = 0; i &lt; num1.size(); i++) { for (int j = 0; j &lt; num2.size(); j++) { multi[i + j] += num1[i] * num2[j]; } } int n = 0; for (int i = 0; i &lt; multi.size(); i++) { n += multi[i]; multi[i] = n % 10; n /= 10; } // 去除前导0 while (multi.size() &gt; 1 &amp;&amp; multi.back() == 0) { multi.pop_back(); } return multi;} 题目 高精度乘法","link":"/2021/07/28/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"随手记","slug":"随手记","link":"/tags/%E9%9A%8F%E6%89%8B%E8%AE%B0/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"算法模版","slug":"算法模版","link":"/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88/"},{"name":"算法模板","slug":"算法模板","link":"/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"},{"name":"资源","slug":"资源","link":"/tags/%E8%B5%84%E6%BA%90/"},{"name":"面试题目总结","slug":"面试题目总结","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"在线秒杀项目","slug":"在线秒杀项目","link":"/tags/%E5%9C%A8%E7%BA%BF%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Tips","slug":"Tips","link":"/categories/Tips/"}]}